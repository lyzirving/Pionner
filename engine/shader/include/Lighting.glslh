#pragma once

#include <Common.glslh>
#include <Buffers.glslh>
#include <PBR.glslh>

const int LIGHT_TECH_SHADOW_MAP = 0;
const int LIGHT_TECH_CASCADE_SHADOW_MAP = 1;

const int ShadowMode_Hard = 1;
const int ShadowMode_Soft = 2;
const int ShadowMode_Soft_2X = 3;
const int ShadowMode_Soft_4X = 4;

const int CASCADE_NUM = 3;

layout (std140) uniform MainLightCasterBlock
{
	mat4 ViewMat;
	mat4 PrjMat;
    vec2 ShadowMapSize;
    float FrustumSize;
} u_mainLightCaster;

layout (std140) uniform DirectionalLightBlock
{
	vec3 Direction;
    vec3 Color;
    float Intensity;
    float Bias;
    float NormalBias;
    int ShadowMode;
    bool CastShadow;
    float ShadowIntensity;
} u_directionalLight;

layout (std140) uniform CascadeShadowMap
{
	int CascadeNum;
    mat4 ViewMat;
	mat4 PrjMats[CASCADE_NUM];
} u_CSM;

vec3 CalculateDirLightsEffect()
{
    // Negate the direction to expect a direction from the fragment towards the light source
    vec3 Li = normalize(-u_directionalLight.Direction);
    vec3 Lh = normalize(Li + m_PBRParams.V);
	vec3 Lradiance = u_directionalLight.Color * u_directionalLight.Intensity;

    // Calculate angles between surface normal and light vector.
	float NdotL = max(0.f, dot(m_PBRParams.N, Li));
	float NdotH = max(0.f, dot(m_PBRParams.N, Lh));

    vec3  F = FresnelSchlickRoughness(max(0.f, dot(Lh, m_PBRParams.V)), m_PBRParams.F0, m_PBRParams.Roughness);
    float D = NdfGGX(NdotH, m_PBRParams.Roughness);
    float G = GaSchlickGGX(NdotL, m_PBRParams.NdotV, m_PBRParams.Roughness);

    vec3 kd = (vec3(1.0) - F) * (1.0 - m_PBRParams.Metalness);
	vec3 diffuseBRDF = kd * m_PBRParams.Albedo;

    // Cook-Torrance
	vec3 specularBRDF = (F * D * G) / max(Epsilon, 4.0 * NdotL * m_PBRParams.NdotV);
	specularBRDF = clamp(specularBRDF, vec3(0.0f), vec3(10.0f));
    return (diffuseBRDF + specularBRDF) * NdotL * Lradiance;
}

float SimpleShadowBias(vec3 lightDir, vec3 N, float bias)
{
    return max(bias * (1.0 - dot(N, lightDir)), bias * 0.1f); 
}

float CalcDirLightHardShadow(sampler2D shadowMap)
{
    vec4 lightSpacePos = u_mainLightCaster.PrjMat * u_mainLightCaster.ViewMat * vec4(m_PBRParams.FragPos, 1.f);    
    vec3 prjCoords = lightSpacePos.xyz / lightSpacePos.w;      // perform perspective divide    
    prjCoords = prjCoords * 0.5 + 0.5;                         // transform to [0,1] range    
    float currentDepth = prjCoords.z;                          // get depth of current fragment from light's perspective    
    float closestDepth = texture(shadowMap, prjCoords.xy).r;   // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)

    vec3 lightDir = normalize(-u_directionalLight.Direction);
    float bias = SimpleShadowBias(lightDir, m_PBRParams.N, u_directionalLight.Bias); 
    return (currentDepth - bias) > closestDepth  ? 1.0 : 0.0;
}

float CalcDirLightPCFShadow(int radius, sampler2D shadowMap)
{   
    vec4 lightSpacePos = u_mainLightCaster.PrjMat * u_mainLightCaster.ViewMat * vec4(m_PBRParams.FragPos, 1.f);    
    vec3 prjCoords = lightSpacePos.xyz / lightSpacePos.w;      // perform perspective divide    
    prjCoords = prjCoords * 0.5 + 0.5;                         // transform to [0,1] range    
    float currentDepth = prjCoords.z;                          // get depth of current fragment from light's perspective        
    
    vec3 lightDir = normalize(-u_directionalLight.Direction);        
    float bias = SimpleShadowBias(lightDir, m_PBRParams.N, u_directionalLight.Bias); 
    
    vec2 texelSize = 1.0 / textureSize(shadowMap, 0);
    int itrCnt = 0;
    float shadow = 0.f;
    //PCF
    for(int x = -radius; x <= radius; ++x)
    {
        for(int y = -radius; y <= radius; ++y)
        {
            float pcfDepth = texture(shadowMap, prjCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += (currentDepth - bias > pcfDepth) ? 1.f : 0.f;  
            itrCnt++;
        }    
    }
    shadow /= float(itrCnt);

    // keep the shadow at 0.0 when outside the far plane region of the light's frustum.
    if(prjCoords.z > 1.0)
        shadow = 0.0;

    return shadow;
}

float CalcDirLightShadow(int mode, sampler2D shadowMap)
{
    float shadow = 0.f;
    if(mode == ShadowMode_Hard)
    {
        shadow = CalcDirLightHardShadow(shadowMap);
    }
    else if(mode == ShadowMode_Soft_2X)
    {
        shadow = CalcDirLightPCFShadow(2, shadowMap);
    }
    else if(mode == ShadowMode_Soft_4X)
    {
        shadow = CalcDirLightPCFShadow(4, shadowMap);
    }
    else
    {
        shadow = CalcDirLightPCFShadow(1, shadowMap);
    }
    return shadow * u_directionalLight.ShadowIntensity;
}